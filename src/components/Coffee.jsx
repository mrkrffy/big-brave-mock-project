/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 coffee.glb 
*/

import React, { useState, useEffect } from "react";
import { useGLTF } from "@react-three/drei";
import Marker from "./Marker";

const coffeeTypes = [
  "Espresso",
  "Doppio",
  "Ristretto",
  "Lungo",
  "Americano",
  "Red Eye",
  "Black Eye",
  "Dead Eye",
  "Affogato",
  "Espresso Con Panna",
  "Café Noisette",
  "Cortado",
  "Flat White",
  "Macchiato",
  "Latte Macchiato",
  "Café Breve",
  "Café Bombón",
  "Cappuccino",
  "Café Latte",
  "Mocha",
  "Vienna Coffee",
  "Gibraltar",
  "Café au Lait",
  "Iced Coffee",
  "Iced Latte",
  "Iced Cappuccino",
  "Cold Brew",
  "Nitro Cold Brew",
  "Frappuccino",
  "Mazagran",
  "Irish Coffee",
  "Baileys Coffee",
  "Kahlúa Coffee",
  "Carajillo",
  "Rüdesheimer Kaffee",
  "Turkish Coffee",
  "Greek Coffee",
  "Cuban Coffee",
  "Café de Olla",
  "Vietnamese Egg Coffee",
  "Ethiopian Coffee",
  "Brazilian Cafézinho",
  "Saudi Qahwa",
  "Indian Filter Coffee",
  "Buna",
  "Bulletproof Coffee",
  "White Coffee",
  "Charcoal Coffee",
  "Mushroom Coffee",
  "Butter Coffee",
];

const minRadius = 0.15; // Closest distance
const maxRadius = 0.25; // Farthest distance
const minDistance = 0.05; // Minimum spacing to avoid overlap

function generateRandomPosition(existingPositions) {
  let position;
  let attempts = 0;

  do {
    const radius = Math.random() * (maxRadius - minRadius) + minRadius; // Randomized distance from center
    const theta = Math.acos(2 * Math.random() - 1); // Random elevation (up/down)
    const phi = Math.random() * Math.PI * 2; // Random azimuth (around)

    // Convert spherical to Cartesian
    const x = radius * Math.sin(theta) * Math.cos(phi);
    const y = radius * Math.sin(theta) * Math.sin(phi);
    const z = radius * Math.cos(theta);

    position = [x, y, z];

    // Avoid overlapping markers
    const tooClose = existingPositions.some(([px, py, pz]) => {
      const dx = x - px;
      const dy = y - py;
      const dz = z - pz;
      return Math.sqrt(dx * dx + dy * dy + dz * dz) < minDistance;
    });

    if (!tooClose) break;

    attempts++;
  } while (attempts < 20);

  return position;
}

export default function Model(props) {
  const { nodes, materials } = useGLTF("/coffee.glb");
  const [markerPositions, setMarkerPositions] = useState([]);

  useEffect(() => {
    let positions = [];
    for (let i = 0; i < coffeeTypes.length; i++) {
      positions.push(generateRandomPosition(positions));
    }
    setMarkerPositions(positions);
  }, []);

  return (
    <group {...props} dispose={null}>
      <group scale={0.01}>
        <group rotation={[-Math.PI / 2, 0, 0]} scale={100}>
          <group position={[0, 0, 0.04]} scale={0.085}>
            <mesh
              geometry={nodes.Coffee_Cup_Coffee_Cup_MAT_0.geometry}
              material={materials.Coffee_Cup_MAT}
            />
            <mesh
              geometry={nodes.Coffee_Coffee_Rosetta_Latte_MAT_0.geometry}
              material={materials.Coffee_Rosetta_Latte_MAT}
              scale={11.834}
            />
          </group>
          <mesh
            position={[0, 0, -0.045]}
            geometry={nodes.Cup_Plate_Coffee_Plate_MAT_0.geometry}
            material={materials.Coffee_Plate_MAT}
          />

          {markerPositions.map((position, index) => (
            <Marker
              key={index}
              position={position}
              label={coffeeTypes[index]}
            />
          ))}
        </group>
      </group>
    </group>
  );
}

useGLTF.preload("/coffee.glb");
